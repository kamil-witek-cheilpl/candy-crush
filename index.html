<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <title>Match-3 Prototype (images)</title>
  <style>
    canvas { background: #1b1e24; display:block; margin:20px auto; }
    body { font-family: system-ui, sans-serif; color:#eee; text-align:center; }
  </style>
</head>
<body>
  <h1>Match-3 Prototype (images)</h1>
  <canvas id="game"></canvas>
  <script>
    // BOARD CONFIG
    const size = 4;           // 4x4 board as requested
    const tileSize = 110;     // tile size in px (adjustable)
    const canvas = document.getElementById("game");
    canvas.width = size * tileSize;
    canvas.height = size * tileSize;
    const ctx = canvas.getContext("2d");

    // Images you provided (remote URLs)
    const imageFiles = [
      "https://images.samsung.com/is/image/samsung/assets/uk/offer/2025-watches-candy-crush/brown-watch.jpg",
      "https://images.samsung.com/is/image/samsung/assets/uk/offer/2025-watches-candy-crush/blue-watch.jpg",
      "https://images.samsung.com/is/image/samsung/assets/uk/offer/2025-watches-candy-crush/black-watch.jpg",
      "https://images.samsung.com/is/image/samsung/assets/uk/offer/2025-watches-candy-crush/white-watch.jpg"
    ];

    // Fallback colors if an image fails to load or CORS blocks loading
    const fallbackColors = ["#b07a4a","#4b89c6","#111111","#f5f5f5"];

    let images = {};    // src -> HTMLImageElement for successfully loaded images
    let grid = null;
    let selected = null;
    let animating = false;

    // Preload images. We set crossOrigin="anonymous" so that if the remote server
    // serves CORS headers the images can be used safely in canvas without tainting.
    // If the server doesn't provide CORS, some browsers may still display the image
    // but canvas may become tainted; we also handle onerror and fall back to color.
    function loadImages() {
      return Promise.all(imageFiles.map(src => new Promise(res => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => { images[src] = img; res(); };
        img.onerror = () => {
          console.warn("Image failed to load or CORS blocked:", src);
          images[src] = null; // explicit null to mark failure
          res();
        };
        img.src = src;
      })));
    }

    function randImage() {
      return imageFiles[Math.floor(Math.random()*imageFiles.length)];
    }

    function createInitialGrid() {
      const g = Array.from({length:size}, () => Array(size).fill(null));
      // Fill avoiding immediate matches
      for (let r=0; r<size; r++) {
        for (let c=0; c<size; c++) {
          let tries = 0, val;
          do {
            val = randImage();
            tries++;
          } while (tries < 20 && (
            (c>=2 && g[r][c-1]===val && g[r][c-2]===val) ||
            (r>=2 && g[r-1][c]===val && g[r-2][c]===val)
          ));
          g[r][c] = val;
        }
      }
      return g;
    }

    // Draw tile with rounded rect then draw the image clipped inside it (or fallback color)
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for (let r=0; r<size; r++) {
        for (let c=0; c<size; c++) {
          const x = c*tileSize, y = r*tileSize;
          // tile background
          ctx.fillStyle = "#2a2d33";
          ctx.roundRect(x+4, y+4, tileSize-8, tileSize-8, 10);
          ctx.fill();

          // content clipped to rounded rect
          ctx.save();
          ctx.beginPath();
          ctx.roundRect(x+6, y+6, tileSize-12, tileSize-12, 8);
          ctx.clip();

          const val = grid[r][c];
          if (val) {
            const img = images[val];
            if (img) {
              // Draw the image scaled to the tile; maintain aspect by covering tile area
              // center-crop behavior:
              const iw = img.width, ih = img.height;
              const tw = tileSize-12, th = tileSize-12;
              const scale = Math.max(tw / iw, th / ih);
              const sw = tw / scale, sh = th / scale;
              const sx = (iw - sw) / 2, sy = (ih - sh) / 2;
              try {
                ctx.drawImage(img, sx, sy, sw, sh, x+6, y+6, tw, th);
              } catch (e) {
                // If drawing fails (e.g., CORS), fallback to color
                const idx = imageFiles.indexOf(val);
                ctx.fillStyle = fallbackColors[idx % fallbackColors.length] || "#777";
                ctx.fillRect(x+6, y+6, tw, th);
              }
            } else {
              // fallback color if image not available
              const idx = imageFiles.indexOf(val);
              ctx.fillStyle = fallbackColors[idx % fallbackColors.length] || "#777";
              ctx.fillRect(x+6, y+6, tileSize-12, tileSize-12);
            }
          } else {
            // empty / cleared
            ctx.fillStyle = "transparent";
            ctx.fillRect(x+6, y+6, tileSize-12, tileSize-12);
          }
          ctx.restore();

          // selection outline
          if (selected && selected.r===r && selected.c===c) {
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 3;
            ctx.strokeRect(x+3, y+3, tileSize-6, tileSize-6);
          }
        }
      }
    }

    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r) {
      if (w < 2*r) r = w/2; if (h < 2*r) r = h/2;
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    }

    function getCellFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const c = Math.floor(mx / tileSize);
      const r = Math.floor(my / tileSize);
      return (r>=0 && r<size && c>=0 && c<size) ? {r,c} : null;
    }

    canvas.addEventListener("click", e => {
      if (animating) return;
      const cell = getCellFromEvent(e);
      if (!cell) return;
      if (!selected) { selected = cell; draw(); return; }
      const dr = Math.abs(cell.r - selected.r);
      const dc = Math.abs(cell.c - selected.c);
      if ((dr + dc) !== 1) { selected = cell; draw(); return; }
      // Attempt swap
      swap(selected, cell);
      const matches = findMatches();
      if (matches.length === 0) {
        // revert swap if no match
        swap(selected, cell);
        selected = cell;
        draw();
        return;
      }
      selected = null;
      resolveMatches(matches);
    });

    function swap(a,b) {
      const tmp = grid[a.r][a.c];
      grid[a.r][a.c] = grid[b.r][b.c];
      grid[b.r][b.c] = tmp;
    }

    function findMatches() {
      const toClear = [];
      // horizontal
      for (let r=0; r<size; r++) {
        let run = 1;
        for (let c=1; c<size; c++) {
          if (grid[r][c] && grid[r][c] === grid[r][c-1]) run++;
          else {
            if (run >= 3) {
              for (let k=0; k<run; k++) toClear.push({r, c: c-1-k});
            }
            run = 1;
          }
        }
        if (run >= 3) for (let k=0; k<run; k++) toClear.push({r, c: size-1-k});
      }
      // vertical
      for (let c=0; c<size; c++) {
        let run = 1;
        for (let r=1; r<size; r++) {
          if (grid[r][c] && grid[r][c] === grid[r-1][c]) run++;
          else {
            if (run >= 3) {
              for (let k=0; k<run; k++) toClear.push({r: r-1-k, c});
            }
            run = 1;
          }
        }
        if (run >= 3) for (let k=0; k<run; k++) toClear.push({r: size-1-k, c});
      }
      // dedupe
      const key = p => `${p.r},${p.c}`;
      const map = new Map();
      toClear.forEach(p => map.set(key(p), p));
      return Array.from(map.values());
    }

    async function resolveMatches(matches) {
      animating = true;
      // Clear
      matches.forEach(({r,c}) => grid[r][c] = null);
      draw();
      await sleep(200);

      // Gravity
      for (let c=0; c<size; c++) {
        let write = size - 1;
        for (let r=size-1; r>=0; r--) {
          if (grid[r][c] !== null) {
            grid[write][c] = grid[r][c];
            if (write !== r) grid[r][c] = null;
            write--;
          }
        }
        for (let r=write; r>=0; r--) grid[r][c] = randImage();
      }
      draw();
      await sleep(150);

      // Cascades
      const next = findMatches();
      if (next.length > 0) {
        await resolveMatches(next);
      } else {
        animating = false;
      }
    }

    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

    // Init: load images, create grid, initial draw
    (async function init(){
      await loadImages();
      grid = createInitialGrid();
      draw();
    })();
  </script>
</body>
</html>