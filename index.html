<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <title>Match-3 Prototype</title>
  <style>
    canvas { background: #1b1e24; display:block; margin:20px auto; }
    body { font-family: system-ui, sans-serif; color:#eee; text-align:center; }
  </style>
</head>
<body>
  <h1>Match-3 Prototype</h1>
  <canvas id="game" width="480" height="480"></canvas>
  <script>
    const size = 8;
    const tileSize = 60;
    const colors = ["#f94144","#f3722c","#f9c74f","#90be6d","#43aa8b","#577590"];
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    let grid = createInitialGrid();
    let selected = null;
    let animating = false;

    function randColor() { return colors[Math.floor(Math.random()*colors.length)]; }

    function createInitialGrid() {
      const g = Array.from({length:size}, () => Array(size).fill(null));
      // Fill avoiding immediate matches
      for (let r=0; r<size; r++) {
        for (let c=0; c<size; c++) {
          let tries = 0, color;
          do {
            color = randColor();
            tries++;
          } while (tries < 20 && (
            (c>=2 && g[r][c-1]===color && g[r][c-2]===color) ||
            (r>=2 && g[r-1][c]===color && g[r-2][c]===color)
          ));
          g[r][c] = color;
        }
      }
      return g;
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for (let r=0; r<size; r++) {
        for (let c=0; c<size; c++) {
          const x = c*tileSize, y = r*tileSize;
          ctx.fillStyle = grid[r][c] || "transparent";
          ctx.beginPath();
          ctx.roundRect(x+6, y+6, tileSize-12, tileSize-12, 10);
          ctx.fill();
          if (selected && selected.r===r && selected.c===c) {
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 3;
            ctx.strokeRect(x+3, y+3, tileSize-6, tileSize-6);
          }
        }
      }
    }

    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r) {
      if (w < 2*r) r = w/2; if (h < 2*r) r = h/2;
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    }

    function getCellFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const c = Math.floor(mx / tileSize);
      const r = Math.floor(my / tileSize);
      return (r>=0 && r<size && c>=0 && c<size) ? {r,c} : null;
    }

    canvas.addEventListener("click", e => {
      if (animating) return;
      const cell = getCellFromEvent(e);
      if (!cell) return;
      if (!selected) { selected = cell; draw(); return; }
      const dr = Math.abs(cell.r - selected.r);
      const dc = Math.abs(cell.c - selected.c);
      if ((dr + dc) !== 1) { selected = cell; draw(); return; }
      // Attempt swap
      swap(selected, cell);
      const matches = findMatches();
      if (matches.length === 0) {
        // revert swap if no match
        swap(selected, cell);
        selected = cell;
        draw();
        return;
      }
      selected = null;
      resolveMatches(matches);
    });

    function swap(a,b) {
      const tmp = grid[a.r][a.c];
      grid[a.r][a.c] = grid[b.r][b.c];
      grid[b.r][b.c] = tmp;
    }

    function findMatches() {
      const toClear = [];
      // horizontal
      for (let r=0; r<size; r++) {
        let run = 1;
        for (let c=1; c<size; c++) {
          if (grid[r][c] && grid[r][c] === grid[r][c-1]) run++;
          else {
            if (run >= 3) {
              for (let k=0; k<run; k++) toClear.push({r, c: c-1-k});
            }
            run = 1;
          }
        }
        if (run >= 3) for (let k=0; k<run; k++) toClear.push({r, c: size-1-k});
      }
      // vertical
      for (let c=0; c<size; c++) {
        let run = 1;
        for (let r=1; r<size; r++) {
          if (grid[r][c] && grid[r][c] === grid[r-1][c]) run++;
          else {
            if (run >= 3) {
              for (let k=0; k<run; k++) toClear.push({r: r-1-k, c});
            }
            run = 1;
          }
        }
        if (run >= 3) for (let k=0; k<run; k++) toClear.push({r: size-1-k, c});
      }
      // dedupe
      const key = p => `${p.r},${p.c}`;
      const map = new Map();
      toClear.forEach(p => map.set(key(p), p));
      return Array.from(map.values());
    }

    async function resolveMatches(matches) {
      animating = true;
      // Clear
      matches.forEach(({r,c}) => grid[r][c] = null);
      draw();
      await sleep(200);

      // Gravity
      for (let c=0; c<size; c++) {
        let write = size - 1;
        for (let r=size-1; r>=0; r--) {
          if (grid[r][c] !== null) {
            grid[write][c] = grid[r][c];
            if (write !== r) grid[r][c] = null;
            write--;
          }
        }
        for (let r=write; r>=0; r--) grid[r][c] = randColor();
      }
      draw();
      await sleep(150);

      // Cascades
      const next = findMatches();
      if (next.length > 0) {
        await resolveMatches(next);
      } else {
        animating = false;
      }
    }

    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

    // Initial render
    draw();
  </script>
</body>
</html>
